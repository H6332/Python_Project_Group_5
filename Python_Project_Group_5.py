# -*- coding: utf-8 -*-
"""Python_Project_Group_5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f6OpgJBHjfBefzJYUgpJCmlil8PYxrNA
"""

import random
from collections import deque
import time


class Board_Information:  # è‡ªå®šç¾©ä¸€å€‹é¡åˆ¥
    def __init__(self, has_been_clicked=False, is_mine=False, is_flag=False):
        self.clicked = has_been_clicked  # é€™å€‹æ ¼å­æ˜¯å¦è¢«é»é
        self.is_mine = is_mine  # é€™æ˜¯ä¸æ˜¯åœ°é›·
        self.flag = is_flag  # é€™æ˜¯ä¸æ˜¯æ——å­
        self.number = 0  # å‘¨åœåœ°é›·æ•¸


# ---------- å»ºç«‹æ£‹ç›¤ ----------
def create_board(level):
    if level == 1:
        rows, cols, mine_count = 9, 9, 10
    elif level == 2:
        rows, cols, mine_count = 16, 16, 40
    elif level == 3:
        rows, cols, mine_count = 16, 30, 99

    matrix = [[Board_Information() for _ in range(cols)] for _ in range(rows)]
    return matrix, rows, cols, mine_count


# ---------- ç¬¬ä¸€æ¬¡é»æ“Šå¾Œæ”¾åœ°é›· ----------
def place_mines(matrix, rows, cols, mine_count, safe_r, safe_c):
    all_positions = [(r, c) for r in range(rows) for c in range(cols)]

    # å°‡ç¬¬ä¸€æ¬¡é»æ“Šèˆ‡å‘¨åœ 8 æ ¼åŠ å…¥å®‰å…¨å€
    safe_positions = set()
    for dr in (-1, 0, 1):
        for dc in (-1, 0, 1):
            nr, nc = safe_r + dr, safe_c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                safe_positions.add((nr, nc))

    available_positions = [
        pos for pos in all_positions if pos not in safe_positions]
    mined_positions = random.sample(available_positions, mine_count)

    for r, c in mined_positions:
        matrix[r][c].is_mine = True

    # è¨­ç½®å‘¨åœåœ°é›·æ•¸
    for r in range(rows):
        for c in range(cols):
            if not matrix[r][c].is_mine:
                matrix[r][c].number = count_adjacent_mines(
                    matrix, r, c, rows, cols)


# ---------- å…¶ä»–éŠæˆ²åŠŸèƒ½ ----------
def introduction():
    print("==== æ­¡è¿ä¾†åˆ°è¸©åœ°é›· ====")
    print("é è¨­ç‚ºã€ŒæŒ–æ˜æ¨¡å¼ã€ï¼Œè¼¸å…¥åº§æ¨™å³å¯æŒ–æ˜")
    print("è¼¸å…¥ 'D' å¯åˆ‡æ›å›ã€ŒæŒ–æ˜æ¨¡å¼ã€ (Dig)")
    print("è¼¸å…¥ 'F' å¯åˆ‡æ›è‡³ã€Œæ’æ——æ¨¡å¼ã€ (Flag)")
    print("è¼¸å…¥ 'R' å¯éš¨æ™‚é‡æ–°é–‹å§‹")
    print("åœ°åœ–ç¬¦è™Ÿï¼š #=æœªç¿»é–‹ *=åœ°é›·")
    print("=======================")


def choose_difficulty():
    while True:
        level = input("è«‹é¸æ“‡é›£åº¦ (1:åˆç´š 2:ä¸­ç´š 3:é«˜ç´š): ")
        if level in ("1", "2", "3"):
            return int(level)
        print("è¼¸å…¥éŒ¯èª¤ï¼Œè«‹é‡æ–°è¼¸å…¥ã€‚")


def count_adjacent_mines(matrix, r, c, rows, cols):
    count = 0
    for dr in (-1, 0, 1):
        for dc in (-1, 0, 1):
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if matrix[nr][nc].is_mine:
                    count += 1
    return count


def print_board(matrix, rows, cols, mine_count, start_time=None):
    print("\n   ", end="")
    for c in range(cols):
        print(f"{c+1:^3}", end="")
    print()
    print("   " + "-" * (cols * 3))

    for r in range(rows):
        print(f"{r+1:<2}|", end="")
        for c in range(cols):
            cell = matrix[r][c]
            if cell.flag:
                symbol = "F"
            elif not cell.clicked:
                symbol = "#"
            else:
                symbol = "*" if cell.is_mine else (
                    str(cell.number) if cell.number > 0 else " ")
            print(f"{symbol:^3}", end="")
        print()
        print()

    # ç‹€æ…‹è¨ˆç®—
    unrevealed_count = 0
    flag_count = 0
    for r in range(rows):
        for c in range(cols):
            if matrix[r][c].flag:
                flag_count += 1
            elif not matrix[r][c].clicked:
                unrevealed_count += 1

    print("-" * (cols * 3 + 4))
    print(
        f"ğŸ“Š ç‹€æ…‹ï¼š ğŸ’£ åœ°é›·ç¸½æ•¸: {mine_count} | ğŸš© å·²æ’æ——: {flag_count} | â–  æœªç¿»é–‹: {unrevealed_count}")
    if start_time is not None:
        elapsed = int(time.time() - start_time)
        print(f"â±ï¸ å·²ç”¨æ™‚é–“ï¼š{elapsed} ç§’")
    print("-" * (cols * 3 + 4))


def toggle_flag(matrix, r, c):
    cell = matrix[r][c]
    if cell.clicked:
        print("ä¸èƒ½åœ¨å·²ç¿»é–‹çš„æ ¼å­æ’æ——ï¼")
        return
    cell.flag = not cell.flag
    print(">>> å·²æ’æ——" if cell.flag else ">>> å·²æ‹”æ——")


def reveal_cell(matrix, rows, cols, r, c):
    cell = matrix[r][c]
    if cell.clicked or cell.flag:
        return False
    cell.clicked = True
    if cell.is_mine:
        return True
    if cell.number == 0:
        queue = deque()
        queue.append((r, c))
        while queue:
            cr, cc = queue.popleft()
            for dr in (-1, 0, 1):
                for dc in (-1, 0, 1):
                    if dr == 0 and dc == 0:
                        continue
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < rows and 0 <= nc < cols:
                        neighbor = matrix[nr][nc]
                        if not neighbor.clicked and not neighbor.flag:
                            neighbor.clicked = True
                            if neighbor.number == 0:
                                queue.append((nr, nc))
    return False


def check_win(matrix, rows, cols, mine_count):
    clicked_count = sum(1 for r in range(rows)
                        for c in range(cols) if matrix[r][c].clicked)
    return clicked_count == rows * cols - mine_count


# ---------- ä¸»éŠæˆ²è¿´åœˆ ----------
def game_loop():
    while True:
        level = choose_difficulty()
        matrix, rows, cols, mine_count = create_board(level)
        current_mode = 'D'
        first_click = True
        start_time = time.time()
        print_board(matrix, rows, cols, mine_count, start_time)

        while True:
            mode_name = "æŒ–æ˜ (D)" if current_mode == 'D' else "æ’æ——/æ‹”æ—— (F)"
            print(f"ç›®å‰æ¨¡å¼: ã€ {mode_name} ã€‘")
            user_input = input(
                f"è«‹è¼¸å…¥ ROW (1~{rows}) æˆ–è¼¸å…¥ D/F åˆ‡æ›, R é‡é–‹: ").upper().strip()

            if user_input == "R":
                print("\nğŸ”„ æ­£åœ¨é–‹å§‹æ–°çš„ä¸€å±€...\n")
                break

            if user_input == "D":
                current_mode = 'D'
                print(">>> åˆ‡æ›ç‚ºï¼šæŒ–æ˜æ¨¡å¼")
                continue

            if user_input == "F":
                current_mode = 'F'
                print(">>> åˆ‡æ›ç‚ºï¼šæ’æ——æ¨¡å¼")
                continue

            try:
                r = int(user_input) - 1
                c = int(input(f"è«‹è¼¸å…¥ COL (1~{cols}): ")) - 1
            except ValueError:
                print("è¼¸å…¥éŒ¯èª¤ï¼Œè«‹è¼¸å…¥æ•¸å­—æˆ–æŒ‡ä»¤ (D, F, R)")
                continue

            if not (0 <= r < rows and 0 <= c < cols):
                print(f"è¶…å‡ºåœ°åœ–ç¯„åœ (è«‹è¼¸å…¥ 1 ~ {rows} ä¹‹é–“çš„æ•¸å­—)")
                continue

            if current_mode == "F":
                toggle_flag(matrix, r, c)
            elif current_mode == "D":
                if first_click:
                    place_mines(matrix, rows, cols, mine_count, r, c)
                    first_click = False
                hit_mine = reveal_cell(matrix, rows, cols, r, c)
                if hit_mine:
                    print("\n" + "="*40 + "\nğŸ’¥ ä½ è¸©åˆ°åœ°é›·ï¼éŠæˆ²çµæŸï¼")
                    for rr in range(rows):
                        for cc in range(cols):
                            matrix[rr][cc].clicked = True
                    print_board(matrix, rows, cols, mine_count, start_time)
                    break

            print_board(matrix, rows, cols, mine_count, start_time)

            if check_win(matrix, rows, cols, mine_count):
                print("ğŸ‰ æ­å–œä½ è´äº†ï¼")
                break

        again = input("è¦å†ç©ä¸€å±€å—ï¼Ÿ(Y/N): ").upper()
        if again != "Y":
            print("æ„Ÿè¬éŠç©ï¼Œå†è¦‹ï¼")
            return


def main():
    introduction()
    game_loop()


if __name__ == "__main__":
    main()
